<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>MoSIS</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css">
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
    <style>
        blockquote {
            font-family: monospace;
        }
    </style>
</head>

<body>
<section class="section">
    <div class="container">
        <div class="columns is-centered">
            <div class="column is-half">

                <h1 class="title">DEVS Assignment</h1>

                <div class="columns">
                    <div class="column is-narrow">
                        <p> Thomas Dooms </p>
                        <p> Basil Rommens </p>
                    </div>
                    <div class="column is-narrow">
                        <p>S<b>0181389</b></p>
                        <p>S<b>0185714</b></p>
                    </div>
                </div>
                <hr>

                <div class="content">
                    <section>
                        <h2>Assumptions</h2>
                        <ul>
                            <li>
                                <p>
                                    The two tracks joining at zeigler Circus first pass through a virtual junction with
                                    traverse_delay of 0 seconds, the junction and the station are connected with a track
                                    of length 0 meters.
                                </p>
                            </li>
                            <li>
                                <p>
                                    Capacity of the trolley over time is interpreted as amount of passengers in the
                                    trolley as the capacity of the trolley would just be a flat line. We measure this at
                                    every possible timestep and not only when the trolley in departing. Combined with
                                    the fact that the trollies spend most of their time at stations, half-empty this
                                    value may be lower than expected.
                                </p>
                            </li>
                            <li>
                                <p>
                                    We don't have any special logic for passengers that have an unreachable destination,
                                    they will just wait indefinitely.
                                </p>
                            </li>
                            <li>
                                <p>Furthermore, when no passengers are available at a station to fill the trolley,
                                the trolley stays waits there until full no matter what. This makes some travel times
                                longer than expected. Stations served by multiple lines will have trollies wait quite
                                long (as there may be fewer passengers with the destination on that line). Which blocks
                                the other trollies in the system. </p>
                            </li>
                            <li>
                                <p>
                                    Lastly we assumed that multiple trollies can be on a junction at the same time and
                                    don't interfere. If a trolley arrives at time 0 and one at time 1, they would leave
                                    the junction at respectively 50 and 51 using default values.
                                </p>
                            </li>
                        </ul>
                    </section>

                    <div class="block"></div>

                    <section>
                        <h2>Part 1: Components of the Model</h2>
                        <h4>Passenger</h4>
                        <img src="img/model/passenger.png" alt=""/>
                        <p>The code can be found <a href="src/models/passenger.py">here</a>.</p>

                        <p> We see here that we use a
                            dataclass to create a new passenger. The passenger has the default attributes, such as the
                            origin and the destination. We also store the all the stations related to a specific line.
                            This is so that the passenger knows where step off. Finally, for extra statistics, we also
                            maintain the time at what the passenger departed and when it arrived as well as the id
                            of the trolley we used.
                        </p>
                        <h4>Trolley</h4>
                        <img src="img/model/trolley.png" alt=""/>
                        <p>The code can be found <a href="src/models/trolley.py">here</a>. </p>

                        <p> As with the passenger, we
                            used a dataclass and have the default parameters of the trolley, like the velocity, the line
                            it serves and the capacity. Naturally, we also keep the passenger list. To reduce code
                            duplication prove to silly mistakes,We have defined a helper function to identify if the
                            trolley is full.
                        </p>
                        <h4>Rail</h4>
                        <img src="img/model/rail.png" alt=""/>
                        <p>The code can be found <a href="src/models/rail.py">here</a>. </p>

                        <p> A rail has an input and an
                            output port, through which they can receive trollies. It also has a given length, as well as
                            a delay (default = 10) during which we need to wait before letting another trolley pass. The
                            last piece of the puzzle is the fact that we have a state, that contains all the trolley and
                            remaining times time trollies on the rail.
                        </p>
                        <p>
                            First off we have a helper function that decrements the timers of each of the trolleys that
                            are waiting by a certain amount. Next up, we have some functions related to DEVS formalism
                            itself. The timeAdvance function does contain the value of the first trolley in the queue,
                            otherwise we have an infinite timeAdvance. So that there won't fire anything in the model.
                            For the internal transition we make it so that there is a trolley that can depart, because
                            it's timer should be 0. As a consequence, we remove the trolley from the queue. As an
                            outputFunction we take the front of the queue and return that trolley. When we have an
                            external transition we first need to decrement the timers by the elapsed time (this is
                            equivalent to ignoring an event and having multiple timers). The remaining time of arrival
                            for a trolley is calculated as follows: we calculate the time if the trolley were to drive
                            full speed (nowait variable). We then take into account if there is a trolley in front of
                            it with a max of both.
                        </p>
                        <h4>Junction</h4>
                        <img src="img/model/junction.png" alt=""/>
                        <p>The code can be found <a href="src/models/junction.py">here</a>. </p>

                        <p> A junction joins multiple
                            rails together and has one output rail. To obtain this in DEVS we have multiple input ports
                            and one single output port. Apart from this, we also need to keep the transfer time of a
                            junction (i.e. how long it will take before another trolley can transfer the junction). We
                            also keep the name of the junction and a state. This state contains a list of lists, which
                            themselves contain 2 elements, namely the trolley and the remaining time.
                        </p>
                        <p>
                            The logic is almost the same as with the rail, apart from the external transition function.
                            We take the trolley out of the inputs and append it to the list of the trolleys to pass.
                        </p>
                        <h4>Split</h4>
                        <img src="img/model/split.png" alt=""/>
                        <p> The code can be found <a href="src/models/split.py">here</a>. </p>

                        <p> For the split we only need one
                            input track, but multiple output tracks. This is almost the exact opposite of the junction,
                            we also need to keep a routing, which line need to be outputted on which output track
                            (e.g. red line goes to output track 0, yellow to 1 and blue also to 1). We also have a state
                            that is initially None.
                        </p>
                        <p>
                            The internal transition always resets the state to None, this signifies the trolley being
                            removed from the split after being outputted. The external transition will temporarily store
                            the trolley in the state. We use the routing in the output function in order to output the
                            trolley on the right output rail. The time advance is only immediate when there is a trolley
                            currently being split otherwise we wait infinitely for the next trolley.
                        </p>
                        <h4>Station</h4>
                        <img src="img/model/station.png" alt=""/>
                        <p> The code can be found <a href="src/models/station.py">here</a>. </p>

                        <p> Most of the code written here
                            is because this is a coupled DEVS, so not a lot can be said about this part.
                            The num_outputs is calculated based on the highest split value, so if a user enters the red
                            line to go to output 10, there will be 10 outputs. The other part is the routing, that has
                            already been described before. Lastly the destinations parameter is the possible
                            destinations that can be used for the passengers generator.
                        </p>
                        <h4>Generator</h4>
                        <img src="img/model/generator.png" alt=""/>
                        <p> The code can be found <a href="src/models/generator.py">here</a>. </p>

                        <p> From the generator we only
                            need an output port in order to receive the passengers on the station. We also need their
                            origin station. We use a set of all the aforementioned possible destinations, and along
                            with that we need the parameters for the normal distribution, mu and sigma. Then we
                            also have the lines which
                            contain the stations for all lines. This is used for passengers to decide whether to board
                            a trolley or not. For the last attribute we have the state, which encompasses the remaining
                            time for the next passenger and the total amount of passengers that have been generated,
                            which is used in the statistics.
                        </p>
                        <p>
                            The distribution method will calculate the time for the next passenger to be generated. When
                            we perform an internal transition we increase the generated passengers by 1 and update the
                            remaining time by a new value generated by the distribution. The time advance will always be
                            the time at which the next passenger will be generated. The output function generates a new
                            passenger, which brings along with it an origin, a destination and the corresponding lines.
                            The statistics function just gives the amount of passengers that have been generated.
                        </p>
                        <h4>Collector</h4>
                        <img src="img/model/collector.png" alt=""/>
                        <p> The code can be found <a href="src/models/collector.py">here</a>. </p>

                        <p> This part of the code
                            makes use of the statistics gathering pattern, as well as the complex state pattern. We have
                            the collector statistics class, which contains some parameters like the average time that a
                            passenger traveled, the amount that exited at a (desired) destination and the amount that
                            exited at their origin destination. We have the collector which keeps the departed
                            passenger (in our terms this means that the passenger arrived if this event occurs), the
                            origin station and all the passengers as well as the elapsed time since the beginning. This
                            elapsed time since the beginning is called the simulated time and is another pattern for
                            DEVS.
                        </p>
                        <p>
                            For the next part we'll discuss the methods. The first method is the time advance, because
                            we never will never perform an internal transition or output something, this must always
                            return infinite. Therefore, we have fewer functions, but we have an external transition,
                            which logs all the passengers that leave the track and as a consequence a trolley. In
                            this method we take that passenger and store it into the list of passengers for that track.
                        </p>
                        <h4>Platform</h4>
                        <img src="img/model/platform.png" alt=""/>
                        <p> The code can be found <a href="src/models/platform.py">here</a>. </p>

                        <p> On a platform we have two
                            input ports (the passenger entry and the request passenger) and an output port (board).
                            These three provide an interface to the generator, the track and the track respectively.
                            The state contains a queue of waiting passengers, a requested parameter and the simulated
                            time. We also keep the origin (station name) of the platform.
                        </p>
                        <p>
                            We first describe the helper method passenger_indices. This method is used to get the
                            indices from all the passengers that are in the queue waiting for a trolley that serves a
                            given line. We use the simulated time pattern described in the course notes. In order to
                            decide what the time advance should be we check if there is a passenger requested by the
                            track, if there is then we set the time advance to 0, otherwise we set it to infinity. The
                            internal transition is performed by selecting all the candidates, that can be on the line.
                            We unset the requested state and remove that retrieved candidate, the first valid candidate,
                            from the queue. For the external transition we need to select the line of the requested
                            passenger. And only when we have passengers waiting for that line we can set the requested
                            parameter in the state to the line that is requested. Otherwise, if we have a passenger
                            entry, we need to add it to the passenger queue. Last but not least, we have the output
                            function, that can only be executed if the there is a requested passenger, and there are
                            candidates. the candidates are then chosen from the candidates list, and only the first
                            candidate is chosen that has a destination that is on the requested line. We also store the
                            departed time of the candidate passenger for later statistics.
                        </p>
                        <h4>Track</h4>
                        <img src="img/model/track-1.png" alt=""/>
                        <img src="img/model/track-2.png" alt=""/>
                        <p> The code can be found <a href="src/models/track.py">here</a>. </p>

                        <p> For this part we chose an
                            atomic DEVS to encode the track. First, we need to set all the different types of
                            waiting times, notice that the first 1 is the amount of seconds. This is because we need to
                            'busy poll' the light for a new trolley to enter. The first part of arriving at a track at a
                            station is a certain arriving delay, for which we wait at a station, the next part is the
                            unboarding of the trolley, followed by the boarding of the trolley. At last, we have the
                            time that it takes to depart from the station. We add some input and output ports as shown
                            in the station diagram. Next up we define the origin of the station and the probability of
                            wrongly unboarding at that station.
                        </p>
                        <p>
                            This passenger indices helper function gives back all the passengers that can leave the
                            trolley, this can be either because they need to be there. Or there is a slight chance that
                            they are confused and get off the trolley (by default, this has a 20 percent chance of
                            happening). The internal transition checks in which state it is and depending on the state
                            it chooses what to do. There is an interesting side note on the random handling.
                            We can choose to do this in a number of ways:

                        </p>
                        <ul>
                            <li> Go over every passenger in the trolley for every unboard trigger and find someone
                                either by luck or desired exit. This has the issue that the first passenger in the list
                                has a way higher chance to exit wrongfully as the 20% is calculated multiple times.</li>
                            <li> Even if we do random sampling this isn't fair.</li>
                            <li>Calculating some combined probability of a random person exiting based on the amount of
                                people also isn't correct as it doesn't allow for multiple wrong exits.</li>
                            <li>Our last option is precalculate the list and keep it around as some kind of temporary
                                state. This is far from elegant but it works. the list of passengers to exit is in
                                state[2] and the current index of which passenger we are at is in state[3]. We need to
                                keep both as otherwise we would be changing the state when we aren't allowed to.
                            </li>
                        </ul>
                        <p> We will now describe the internal transition</p>
                        <ul>
                            <li>
                                When the trolley has finished arriving then the state must become unboarding.
                            </li>
                            <li>
                                When we discover that we are in the state unboarding and we unboarded everyone in the
                                list, i.e. the counter is the length of the list, we can get to the boarding
                                phase. This phase takes all the passengers that can board and boards them onto the
                                trolley and set the state to the boarding state and keep the trolley also in it.
                            </li>
                            <li>
                                When we only have that we were in the unboarding phase we need to lower the amount of
                                passengers that can unboard.
                            </li>
                            <li>
                                When we try to board when the trolley is full then we can move to the state departing.
                            </li>
                            <li>
                                When we are in the state departing, then we just can depart.
                            </li>
                        </ul>
                        <p>
                            For the external transition we need to fire we need to have a board input or a dequeue
                            input.
                        </p>
                        <ul>
                            <li>
                                If we have a board input we need to check that we are in the boarding state, check
                                that the capacity of the passenger is lower or equal to that of the trolley, and check
                                that the destination of the boarding passenger is on the line that it is boarding. We
                                take the passenger of the input and store the name of the trolley within the
                                passenger. Then we add the passenger to the passengers that have boarded the trolley.
                            </li>
                            <li>
                                For the dequeue of the trolley input, we need to check that the state is none and the
                                trolley arriving. This is so we can set the state to arriving and the trolley that has
                                been given to the track.
                            </li>
                        </ul>
                        <p>
                            The time advance just keeps the waiting time of the current phase or state it's in. For the
                            output function we have different actions depending on the internal state.
                        </p>
                        <ul>
                            <li>
                                When we are in the state none, there is nothing to return and no trolley to request.
                            </li>
                            <li>
                                When we are in the unboarding state, and we still have to unboard passenger from the
                                list, we need to signal the collector to receive the passenger that has just unboarded.
                            </li>
                            <li>
                                When the state is boarding and the trolley still isn't full we can request a passenger
                                for the line the trolley is a part of.
                            </li>
                            <li>
                                When we are in the departing state we can move to the split also the called the output.
                            </li>
                        </ul>
                        <h4>Light</h4>
                        <img src="img/model/light.png" alt=""/>
                        <p> The code can be found <a href="src/models/light.py">here</a>. </p>

                        <p> We have 2 different input
                            ports: the request of a trolley and the input of a trolley. The output is the dequeue of a
                            trolley. We also keep a queue of trolleys in the state and the fact that there is a trolley
                            requested to false.
                        </p>
                        <p>
                            The time advance will be 0 if there is a trolley requested, otherwise infinity. We always
                            will reset the requested when we perform an internal transition and pop the last trolley
                            from the queue, as we do the internal transition as last thing. The external transition will
                            check if there is a request for a trolley and set it to true if the queue has a length
                            larger than 0, otherwise nothing will be returned. We should also add the trolley to the
                            queue if there is a trolley that arrived at the light. The output function returns the
                            trolley that is first in the queue.
                        </p>
                    </section>
                    <section>
                        <h2>Part 2: Creating the network</h2>
                        <p>
                            In order to represent the network, we've chosen to employ the JSON format. This is because
                            we thought this would the most light-weight format to create a flexible solution of modeling
                            the rail network. In the next paragraphs we'll discuss the format of the JSON and then the
                            code that is used to interpret this JSON. The json for the network described int assignment
                            can be found <a href="networks/city.json">here</a>. The network hasn't undergone many big
                            transformations, if there is a transformation that is worth of mentioning, we will do this
                            in the JSON format part.
                        </p>
                        <h4>JSON format</h4>
                        <img src="img/json/stations.png" alt=""/>
                        <p>
                            First of all we have the stations. Its value is a list that contains the name of a
                            station, and a split. This split is a dictionary of the outgoing lines at that point. The
                            names are the line colours and the numbers are on which track they need to go. We look at
                            these outgoing lines clock-wise, starting from 9 o'clock (this may seem weird, but it's very
                            intuitive once you get it).
                        </p>
                        <img src="img/json/junctions.png" alt=""/>
                        <p>
                            Next up we have the junctions. Each junction has a name, an input and possibly the
                            transfer_time. The transfer time is the time that it takes to take the junction, by default
                            this is 50, so it is not specified for 2 of the 3 junctions. The third junction belongs to
                            a station. The last junction is added, because a station can't combine 2 different tracks as
                            described in the assumptions.
                        </p>
                        <img src="img/json/rails.png" alt=""/>
                        <p>
                            Now, we have the rails list. This contains a list of all the possible rails in the model.
                            Each entry contains the length, the start station/junction name and the end station/junction
                            name. You can see that sometimes we define the start_port and the end_port. This needs only
                            to be done when we depart from a station and arrive in a junction, this is so it knows which
                            output from the station or input from the junction it has to connect to.
                        </p>
                        <img src="img/json/lines.png" alt=""/>
                        <p>
                            Following the rails list, we have the lines. The lines are again a list. We first have the
                            name (or colorin our case) of the line and then all the stations that it contains.
                        </p>
                        <img src="img/json/trollies.png" alt=""/>
                        <p>
                            Lastly, we have a list of trollies. Each of these entries contain the velocity of the
                            trolley, the location at which they start and the line to which they belong. Each trolley
                            also has a name used for the readability and traceability of the statistics.
                        </p>
                        <h4>JSON parsing</h4>
                        <p>
                            In order to read and serialize the JSON file we need the
                            <a href="src/classes.py">classes</a> file and the <a href="src/parse.py">parse</a> file.
                            The classes file is used to represent the data for each of the model elements. The parse
                            file contains the code to parse the JSON file format into the specified classes. We can look
                            at the classes as some sort of intermediary representation of the system. If any other
                            parsing method is required we can use this to easily extend the system. We use the
                            dictionary splat operator (turning a dict, or JSON object into the key value pairs as
                            arguments to a function or constructor)to turn the dicts returned by the parser into
                            arguments for the classes in order to create objects.
                        </p>
                    </section>
                    <section>
                        <h2>Part 3: Prove the validity of model</h2>
                        <img src="img/network/main.svg" alt=""/>
                        <p>
                            The figure depicted above, shows the details the created rail network. We can clearly see
                            the network that has been created. However, not all the lines show up in the image, and that
                            is because we've only drawn the rails where the trolleys can ride on. The lengths of all
                            these tracks is also indicated, as well as the name of each of the stations. There is,
                            however, one extra junction and that junction is the Zeigler Junction. This is because a
                            station doesn't have junction functionality built in.
                        </p>
                        <img src="img/network/visualize-network.png" alt=""/>
                        <p>
                            In order to visualize the code we've used the visualize method of the class network. To do
                            this we used the dot language. First, we created nodes for each of the stations and the
                            junctions. Then we connected the junctions and stations, as described by the read network.
                            We do this by going over all the rails and connecting each of the input ports to the
                            corresponding output ports, which represent the stations/junctions.
                        </p>
                    </section>
                    <section>
                        <h2>Part 4: Statistics</h2>
                    </section>
                    <section>
                        <h2>Part 5: Simulation</h2>
                    </section>
                    <section>
                        <h2>Part 6: Only reachable stations fix</h2>
                    </section>
                    <section>
                        <h2>Part 7: Optimizing the values</h2>
                    </section>
                    <section>
                        <h2>Part 8: Prove non-random model validity</h2>
                    </section>
                </div>
            </div>
        </div>
    </div>
</section>
</body>
</html>