<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>MoSIS</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css">
    </head>
    <body>
        <section class="section">
            <div class="container">
            <div class="columns is-centered">
            <div class="column is-half">

                <h1 class="title">Modelica assignment</h1>

                <div class="columns">
                    <div class="column is-narrow">
                        <p> Thomas Dooms </p>
                        <p> Basil Rommens </p>
                    </div>
                    <div class="column is-narrow">
                        <p>S<b>0181389</b></p>
                        <p>S<b>0185714</b></p>
                    </div>
                </div>
                <hr>

            <div class="content">
            <h4> Lotka-Volterra</h4>
                <b> Does this system stabilize? Why (not)? How can you tell? </b>
                <p>No, it is a cyclic system, so it will never stabilize.
                    This is easy to see in the parametric graph,
                    where it would converge(spiral inward) to a certain point if
                    it were to stabilize at some point. </p>

                <p> Most integrators will converge (probably due to numerical error) after a very long time,
                    Here is an example of the ircsko integrator using 10 000 years.</p>

            <img src="images/lotka_convergence.png" alt="convergence">

            <p>We also tried playing with the integration parameters and select different methods.
                This is al made using the block diagram implementation. </p>

            <p> The following graphs are calculated with the Rungekutta integration method.</p>
            <img src="images/lotka_100.png" alt="rungekutta">
            <img src="images/lotka_parametric.png" alt="rungekutta">

            <p> The following graphs are calculated with the Dassl integration method.
                The outlier is due to the start being higher for some reason.
                Also, it is remarkable that the peaks are only 15 high instead of 25 for the previous one. </p>
            <img src="images/lotka_dassl.png" alt="dassl">
            <img src="images/lotka_dassl_param.png" alt="dassl">

            <p> Some integrators give very weird results, like SymSolvercc and Qss</p>
            <img src="images/lotka_symsolver.png" alt="symsolver">
            <img src="images/lotka_qss.png" alt="qss">


            <p> These are the normal charts using the text model.
                We will now try to alter some of these parameters.</p>

            <blockquote>
                model LotkaVolterra<br>
                  output Real x(start=10, fixed=true);<br>
                  output Real y(start=10, fixed=true);<br>
                  parameter Real alpha=1.5;<br>
                  parameter Real beta=0.7;<br>
                  parameter Real delta=0.2;<br>
                  parameter Real gamma=0.2;<br>
                equation<br>
                  der(x) = alpha*x-beta*x*y;<br>
                  der(y) = delta*x*y-gamma*y;<br>
                end LotkaVolterra;<br>
            </blockquote>

            <img src="images/lotka_normal.png" alt="default parameters">
            <img src="images/lotka_normal_param.png" alt="default parameters">

            <p> These are the graphs with alpha = 15.</p>
            <img src="images/lotka_a15.png" alt="alpha = 15">
            <img src="images/lotka_a15_param.png" alt="alpha = 15">

            <p> These are the graphs with beta = 7.</p>
            <img src="images/lotka_b7.png" alt="beta = 7">
            <img src="images/lotka_b7_param.png" alt="beta = 7">

            <p> These are the graphs with delta = 2.</p>
            <img src="images/lotka_d2.png" alt="delta = 2">
            <img src="images/lotka_d2_param.png" alt="delta = 2">

            <p> These are the graphs with gamma = 2.</p>
            <img src="images/lotka_g2.png" alt="gamma = 2">
            <img src="images/lotka_g2_param.png" alt="gamma = 2">

			<h4>Look up model</h4>

			<blockquote>
            model step1<br>
            output Real vel(start=0, fixed=true);<br>
            equation<br>
            vel = if (time &gt; 10) then 0 elseif (time &gt; 170) then 10 elseif (time &gt; 200) then 8 elseif (time &gt; 260) then 18 else 12;<br>
            annotation(experiment(StopTime=500));<br>
            end step1;<br>
			</blockquote>

            <h4>Exercise 4</h4>
            <img src="images/ex4_acc.png" alt="trolley acceleration">
            <img src="images/ex4_traction.png" alt="trolley traction">

            <p>
                The max positive displacement due to acceleration is around 0.17 while the negative is -0.23.
                So the passengers will not fall.
            </p>

            <p>
                D<sub>min</sub> and D<sub>max</sub> define the range in which no action is taken.
                So the value will always oscillate within this range. On the second image we can see if we set the max,
                the function oscillates only under the target function.
            </p>

            <h4>Exercise 5</h4>

            <img src="images/dminmax5-5.png" alt="min=-5 max=5">
            <img src="images/dminmax50.png" alt="min=0 max=5">
            <p>
                g defines the force or slope with which the value oscillates.
                If this value is higher it oscillates faster as can be seen on the images.
            </p>
            <img src="images/g500.png" alt="low g value">
            <img src="images/g10000.png" alt="high g value">

            <p>We have no if-statements technically, only piecewise constructors</p>

            <p> A when will only execute the code the moment the event becomes active,
                meaning only when the value reaches the threshold it will execute the statement.
                If it were allowed to use when statements in this code fragment this wouldn't change anything.
                Using the if method, each iteration we set active to true or false
                while using when we only set active once each time a threshold is reached.
                Which could be more efficient.
            </p>

            <blockquote>
                active = if u > d_max then true elseif u < d_min then false else pre(active);
            </blockquote>

                <p> Our other line calculating the force would behave differently
                    if changed to when as the force would be 0 most of the time.
                    The estimation would oscillate around d_max continuously as then the event is triggered over and over.
                </p>

                <blockquote>
                    F = if active then g else 0;
                </blockquote>

            <h4>Exercise 6</h4>
            <img src="images/pid_acc.png" alt="trolley acceleration">
            <img src="images/pid_sim.png" alt="trolley velocities">
		</div>

            </div>
            </div>
            </div>
        </section>
    </body>
</html>
