<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>MoSIS</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9.3/css/bulma.min.css">
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
    >
</head>
<body>
<section class="section">
    <div class="container">
        <div class="columns is-centered">
            <div class="column is-half">

                <h1 class="title">Modelica assignment</h1>

                <div class="columns">
                    <div class="column is-narrow">
                        <p> Thomas Dooms </p>
                        <p> Basil Rommens </p>
                    </div>
                    <div class="column is-narrow">
                        <p>S<b>0181389</b></p>
                        <p>S<b>0185714</b></p>
                    </div>
                </div>
                <hr>

                <div class="content">
                    <h2> Causal block diagrams </h2>
                    <h4> Complete PID/plant </h4>
                    <p> The PIDBlock is just a simple implementation of a PID controller,
                        the block consists of the derivation, integral and proportional component,
                        multiplied by their respective parameter and summed together at the end.</p>

                    <p> The plant block is a little more complicated due to all the parameters.
                        These are all multiplied or divided or negated as necessary.
                        The most important part is the loop back into the integral.
                    </p>

                    <p> The lookup is just a simple mutliplex chain based on the time.</p>

                    <p>The root block just ties everything together
                        in the same way as the previous assignment.
                    </p>

                    <img src="images/trollies.drawio.svg" alt="">

                    <div class="block"> </div>
                    <h4> Forward Euler </h4>
                    <p> Not much to explain here, just a simple accumulator and then the formula. </p>
                    <img src="images/forward.drawio.svg" alt="">

                    <div class="block"> </div>
                    <h4> Simpson integrator </h4>

                    <p> This is the most complicated of them all probably,
                        we will start with explaining the Simpson block.
                        It is important to notice that this is an incomplete standalone block,
                        meaning it generates wrong outputs for iteration 0 and 1.
                    </p>
                    <p>
                        The logic itself is quite simple starting with a chain of 2 delay blocks representing
                        F(a), F((b - a) / 2) and f(b), the middle factor is
                        then multiplied by 4 and the whole thing is divided by 6 as the formula dictates.
                    </p>
                    <p>One interesting detail is the other delay block,
                        my first thought was to be smart about it and not
                        just multiply delta_t by 2 for the interval, but then we
                        realised the formula won't work for dynamic delta_t.
                        We decided to leave it in because that way it can more
                        easily be checked if that precondition is satisfied.
                    </p>


                    <p> The root then contains the logic for deciding
                        which integration method should be used and/or accumulated to the total result.
                        The bottom part just calculates both integrals,
                        the top part then computes whether there is an even or odd amount of points.
                        Based on that we multiplex trapezoid on even and simpson on odd points.
                        The exception is on step 1 where we just return IC.
                    </p>

                    <p> The right part contains logic about 'forgetting' the trapezoid calculation.
                        We can see that sometimes the delay block is set equal to the sum,
                        or the output of itself based on the amount of points. </p>
                    <img src="images/simpson2.drawio.svg" alt="">

                    <div class="block"> </div>
                    <h2> Trapezoid </h2>
                    <p> The trapezoid block is quite trivial and already covered elsewhere.</p>
                    <img src="images/trapezoid.drawio.svg" alt="">

                    <div class="block"> </div>
                    <h4> Factorial </h4>
                    <p> The factorial block is just a block that remembers both the
                        total up until now and the current tick.
                    </p>
                    <p> We rotated the +1 for extra style points.</p>
                    <img src="images/factorial.drawio.svg" alt="">

                    <h2> LaTeX verification/errors </h2>
                    <p>#!!!!!!!!!!!!!!111111 TODO LINK !!!!!!!!!!!!!!1#</p>

                    <h2> Experimenting with constant delta_t </h2>
                    <p> These experiments are done using the forward Euler method. </p>

                    <p>We start with picking a standard delta_t and see the results we would expect.</p>
                    <img src="images/delta0_3.png" alt="">

                    <p> Using very small delta's does not result in noticeable changes. </p>
                    <img src="images/delta0_01.png" alt="">

                    <p> When going up in delta we see the velocity getting quite erratic.</p>
                    <img src="images/delta5.png" alt="">

                    <p> At very high delta's the behaviour gets very chaotic oscillating dramatically around the lookup speed.</p>
                    <p> We also notice that the lookup table is getting very weird as the lines are not vertical anymore. </p>
                    <img src="images/delta7_2.png" alt="">

                    <p> Even higher delta's do cause numerical instability causing the graph to spiral out of control </p>

                    <h2> Assignment structure </h2>
                    <p> Our file structure consists of 3 main folders, code, convert and images. </p>

                    <p> The code contains the whole codebase provided to us
                        along with some modifications in the CDB/lib/std and such.
                        The models that we used can also be found there.
                    </p>

                    <p> The convert folder contains the draw.io -> python library that was given to us.
                        All our draw.io files can be found there.
                    </p>

                    <p> Lastly the image folder contains all the images found in the report. </p>

                    <p> When changing the integration method, we don't see any noticeable differences.
                        The order is, backward Euler, Simpson and Trapezoid.
                    </p>

                    <img src="images/delta_bwe.png" alt="">
                    <img src="images/delta_simp.png" alt="">
                    <img src="images/delta_trap.png" alt="">

                    <h2> Adaptive step size </h2>

                    <p> We already showed that making delta smaller doesn't really change the graph after a certain point.
                        To be very sure though we ran a last experiment on a subset of the time frame using a tiny delta and a small delta.
                        The first image is using delta = 0.001 and the second is using 0.1
                    </p>

                    <img src="images/small_delta0_001.png" alt="">
                    <img src="images/small_delta0_1.png" alt="">

                    <p> Again we see no noticeable difference. One important detail of using adaptive step size is computation cost.
                        Being smart about this variable can cut simulation costs by orders of magnitude in many cases.
                    </p>
                </div>

            </div>
        </div>
    </div>
</section>
</body>
</html>